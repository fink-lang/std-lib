# TODO: should all js-interop imports be virtual imports from e.g. @fink/runtime/*
# and have the compiler translate it to the appropriate runtime module
{_iter_, _next_} = import '@fink/js-interop/runtime.js'
{_len_, _is_empty_, _join_, _reverse_, _sort_, _zip_} = import '@fink/js-interop/runtime.js'

{max_int} = import './num.fnk'
{is_fn} = import './fn.fnk'



iter = _iter_
next = _next_

is_empty = _is_empty_
length = _len_

zip = _zip_
reverse = _reverse_
join = _join_
sort = _sort_



drop = fn num_items:
  filter , idx=0:
    [idx >= num_items, idx + 1]



drop_last = fn num_items: fn iterable:
  pipe iterable:
    map item, buffer=[]:
      ...match buffer:
        num_items > length ?:
          [[], [...buffer, item]]
        else:
          [out, ...rest] = buffer
          [[out], [...rest, item]]



take = fn num_items: fn iterable:
  match num_items:
    0: []
    else:
      iterable | until , ctr=1:
        [ctr >= num_items, ctr + 1]



take_last = fn num_items: fn iterable:
  last = {}

  pipe iterable:
    chain [last]
    map item, buffer=[]:
      ...match item:
        last:
          [buffer, []]
        else:
          match buffer:
            num_items > length ?:
              [[], [...buffer, item]]
            else:
              [, ...rest] = buffer
              [[], [...rest, item]]



slice = fn start, end=max_int: fn iterable:
  match true:
    end - start == 0:
      []

    start < 0 and end < 0:
      pipe iterable:
        take_last -start
        drop_last -end

    start < 0:
      pipe iterable:
        take_last -start
        take end + start

    end < 0:
      pipe iterable:
        drop start
        drop_last -end

    else:
      pipe iterable:
        drop start
        take end - start



repeat = fn repititions: fn item:
  pipe:
    unfold: item
    take repititions



count = fn start, step=1:
  pipe start - step:
    unfold value:
      value + step



range = fn start, end, step=1:
  [true_start, true_end] = match end:
    {}: [start, end]
    else: [0, start]

  pipe true_start - step:
    unfold cntr:
      cntr + step
    while cntr:
      cntr < true_end



equals = fn it1, it2:
  match length it1:
    ? != length it2: false
    else:
      [eq=true] = pipe zip it1, it2:
        map [item1, item2]: item1 == item2
        filter found: not found
      eq



enumerate = fn start=0, step=1:
  map item, cntr=start:
    [[cntr, item], cntr + step]



cycle = unfold items:
  ...items



flatten = map items:
  ...items



chain = fn ...iterables: fn iterable:
  flatten [iterable, ...iterables]



unique = filter item, known=[]:
  [not item in known, [...known, item]]



insert_at = fn idx, items: fn iterable:
  ignore = {}

  pipe iterable:
    chain [ignore]

    map item, curr=0:
      all = match curr:
        idx: items | chain [item]
        else: [item]
      ...[all, curr + 1]

    filter item:
      item != ignore



find_index = fn item_to_find: fn iterable:
  [[, idx]] = pipe iterable:
    map item, idx=0:
      [[item, idx], idx + 1]

    chain [[item_to_find, -1]]

    filter [item]:
      match item_to_find:
        is_fn ?: item_to_find item
        item: true
        else: false
  idx



item_at = fn idx: fn iterable:
  [item] = iterable | filter , curr_idx=0:
    [idx == curr_idx, curr_idx + 1]
  item



select = fn indices: fn iterable:
  indices | map idx:
    iterable | item_at idx



compress = fn selectors: fn iterable:
  pipe zip iterable, selectors:
    filter [, selected]: selected
    map [item]: item



product = fn ...iterables:
  [iterable, ...rest] = iterables

  match rest:
    0 == length ?:
      iterable | map item: [item]
    else:
      # [...pools] = rest | map items: [...items]
      pipe iterable:
        map item:
          ... pipe product ...rest: #...pools:
            map items:
              [item, ...items]



permutations = fn len: fn [...iterable]:
  pool_len = length iterable
  expected_len = match len:
    {}: len
    else: pool_len

  idx_range = range pool_len

  pipe idx_range:
    repeat expected_len
    product ...?
    map indices:
      ... match unique indices:
        expected_len == length ?:
          [[... iterable | select indices]]
        else:
          []



combinations = fn len: fn [...iterable]:
  pool_len = length iterable
  idx_range = range pool_len

  pipe idx_range:
    permutations len
    map indices:
      ... match indices:
        equals ?, indices | sort _:
          [[... iterable | select indices]]
        else:
          []



pairs = fn iterable:
  pipe iterable:
    map item, last=0:
      [[last, item], item]
    drop 1



chunks = fn len, fill: fn iterable:
  fill_items = fill | repeat len - 1

  pipe iterable:
    chain fill_items
    map item, group=[]:
      items = [...group, item]

      ... match items:
        len == length ?:
          [[items], []]
        else:
          [[], items]

